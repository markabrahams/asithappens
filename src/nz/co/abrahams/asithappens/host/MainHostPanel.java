/*
 * MainHostPanel.java
 *
 * Created on 4 May 2005, 21:31
 *
 * AsItHappens - real-time network monitor
 * Copyright (C) 2006  Mark Abrahams
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

package nz.co.abrahams.asithappens.host;

import nz.co.abrahams.asithappens.core.DataType;
import nz.co.abrahams.asithappens.storage.DataSets;
import nz.co.abrahams.asithappens.storage.Device;
import nz.co.abrahams.asithappens.collectors.DataCollector;
import nz.co.abrahams.asithappens.snmputil.SNMPException;
import nz.co.abrahams.asithappens.core.DBException;
import nz.co.abrahams.asithappens.cartgraph.TimeSeriesContext;
import nz.co.abrahams.asithappens.cartgraph.DataGraph;
import nz.co.abrahams.asithappens.uiutil.ErrorHandler;
import java.net.*;
import javax.swing.*;
import nz.co.abrahams.asithappens.uiutil.DeviceSelectorModel;
import nz.co.abrahams.asithappens.uiutil.DeviceSelectorPanel;
//import org.apache.log4j.Logger;

/**
 * The graphical pane for creating bandwidth graphs.
 *
 * @author  mark
 */
public class MainHostPanel extends javax.swing.JPanel {
    
    /** Collector types */
    public static final String[] COLLECTOR_TYPES = { "Host Resources", "Net-SNMP", "Cisco" };
    
    /** String to display in lists where no choice is given */
    public static final String NO_CHOICE[] = {"default"};
    
    /** Host resources collector type */
    public static final int COLLECTOR_TYPE_HR = 0;
    
    /** UCD collector type */
    public static final int COLLECTOR_TYPE_UCD = 1;
    
    /** Cisco collector type */
    public static final int COLLECTOR_TYPE_CISCO = 2;
    
    /** The device for which ports are enumerated */
    private Device device;

    /** HR processor SNMP interface to device */
    private ProcessorHRSNMP processorHRSNMP;
    
    /** HR memory SNMP interface to device */
    private MemoryHRSNMP memoryHRSNMP;

    /** Cisco memory SNMP interface to device */
    private MemoryCiscoSNMP memoryCiscoSNMP;
    
    /** Device selector panel */
    private DeviceSelectorPanel deviceSelectorPanel;

    /** Creates new form MainHostPanel */
    public MainHostPanel() {
        initComponents();
        initComponentsFinish();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pollLabel = new javax.swing.JLabel();
        pollField = new javax.swing.JTextField();
        pollUnitsLabel = new javax.swing.JLabel();
        collectorTypeComboBox = new JComboBox(COLLECTOR_TYPES);
        resourcesButton = new javax.swing.JButton();
        processorsTitleLabel = new javax.swing.JLabel();
        processorsPane = new javax.swing.JScrollPane();
        storageTitleLabel = new javax.swing.JLabel();
        storagePane = new javax.swing.JScrollPane();
        storeDataCheckBox = new javax.swing.JCheckBox();
        processorButton = new javax.swing.JButton();
        storageButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();

        setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        pollLabel.setText("Poll Interval");
        add(pollLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 50, 90, 20));

        pollField.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        pollField.setText("2000");
        add(pollField, new org.netbeans.lib.awtextra.AbsoluteConstraints(110, 50, 50, -1));

        pollUnitsLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        pollUnitsLabel.setText("ms");
        add(pollUnitsLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(170, 50, 20, 20));

        collectorTypeComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                collectorTypeComboBoxActionPerformed(evt);
            }
        });
        add(collectorTypeComboBox, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, 50, 160, -1));

        resourcesButton.setText("Enumerate Host Resources");
        resourcesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resourcesButtonActionPerformed(evt);
            }
        });
        add(resourcesButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 90, 450, -1));

        processorsTitleLabel.setText("Processor list");
        add(processorsTitleLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 130, 200, -1));
        add(processorsPane, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 150, 200, 150));

        storageTitleLabel.setText("Storage/Memory list");
        add(storageTitleLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 130, 200, -1));
        add(storagePane, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 150, 200, 150));

        storeDataCheckBox.setText("Store collected data");
        add(storeDataCheckBox, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 310, 180, -1));

        processorButton.setText("Processor Graph");
        processorButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                processorButtonActionPerformed(evt);
            }
        });
        add(processorButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 350, 200, -1));

        storageButton.setText("Storage/Memory Graph");
        storageButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                storageButtonActionPerformed(evt);
            }
        });
        add(storageButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 350, 200, -1));

        jLabel1.setText("Type");
        add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(260, 50, -1, 20));
    }// </editor-fold>//GEN-END:initComponents
    
    private void initComponentsFinish() {
        deviceSelectorPanel = new DeviceSelectorPanel(false);
        add(deviceSelectorPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 450, -1));
    }
    
            
    private void collectorTypeComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_collectorTypeComboBoxActionPerformed
        device = null;
        processorsTitleLabel.setText("Processor list");
        storageTitleLabel.setText("Storage/Memory list");
        processorsPane.setViewportView(new javax.swing.JList());
        storagePane.setViewportView(new javax.swing.JList());
    }//GEN-LAST:event_collectorTypeComboBoxActionPerformed
    
    private void storageButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_storageButtonActionPerformed
        //DeviceSelectorModel deviceSelector;
        //String deviceName;
        DataCollector collector;
        DataSets data;
        TimeSeriesContext context;
        DataGraph graphFrame;
        int storageIndex;
        String storageString;
        Device currentDevice;
        MemoryUCDSNMP memoryUCDSNMP;
        int pollInterval;
        
        pollInterval = Integer.parseInt(pollField.getText());
        //deviceSelector = deviceSelectorPanel.getModel();
        //deviceName = deviceSelector.getName();
        if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_HR ) {
            try {
                storageIndex = memoryHRSNMP.getStorageIndex()[((JList)(storagePane.getViewport().getView())).getSelectedIndex()];
                storageString = (String)((JList)storagePane.getViewport().getView()).getSelectedValue();
                collector = new MemoryHRCollector(memoryHRSNMP, pollInterval, storageIndex);
                data = new DataSets(DataType.STORAGE, collector, device, pollInterval, storageString, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (NullPointerException e) {
                ErrorHandler.modalError(this, "Please enumerate resources on a device and select a storage object",
                        "No storage object selected");
            } catch (ArrayIndexOutOfBoundsException e) {
                ErrorHandler.modalError(this, "Please select a storage object", "No storage object selected");
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + device.getName() + "\" is valid",
                        "Unknown host " + device.getName());
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + device.getName(), e);
            }
        }
        
        else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_UCD ) {
            try {
                storageIndex = ((JList)(storagePane.getViewport().getView())).getSelectedIndex();
                storageString = (String)((JList)storagePane.getViewport().getView()).getSelectedValue();
                //currentDevice = new Device(deviceField.getText(), communityField.getText());
                memoryUCDSNMP = new MemoryUCDSNMP(device);
                collector = new MemoryUCDCollector(memoryUCDSNMP, pollInterval, storageIndex);
                data = new DataSets(DataType.STORAGE, collector, device, pollInterval, storageString, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (NullPointerException e) {
                ErrorHandler.modalError(this, "Please enumerate resources on a device and select a memory type",
                        "No memory type selected");
            } catch (ArrayIndexOutOfBoundsException e) {
                ErrorHandler.modalError(this, "Please select a memory type", "No memory type selected");
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + device.getName() + "\" is valid",
                        "Unknown host " + device.getName());
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + device.getName(), e);
            }
        }
        
        else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_CISCO ) {
            try {
                storageIndex = memoryCiscoSNMP.getStorageIndex()[((JList)(storagePane.getViewport().getView())).getSelectedIndex()];
                storageString = (String)((JList)storagePane.getViewport().getView()).getSelectedValue();
                //currentDevice = new Device(deviceField.getText(), communityField.getText());
                collector = new MemoryCiscoCollector(memoryCiscoSNMP, pollInterval, storageIndex);
                data = new DataSets(DataType.STORAGE, collector, device, pollInterval, storageString, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (NullPointerException e) {
                ErrorHandler.modalError(this, "Please enumerate resources on a Cisco device and select a memory pool",
                        "No memory pool selected");
            } catch (ArrayIndexOutOfBoundsException e) {
                ErrorHandler.modalError(this, "Please select a memory pool", "No memory pool selected");
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + device.getName() + "\" is valid",
                        "Unknown host " + device.getName());
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + device.getName(), e);
            } catch (ClassCastException e) {
                ErrorHandler.modalError(null, "Please ensure that the device supports Cisco memory MIB",
                        "Cannot find Cisco memory pool information on device " + device.getName(), e);
            }
        }
    }//GEN-LAST:event_storageButtonActionPerformed
    
    /** Creates a new processor graph. */
    private void processorButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_processorButtonActionPerformed
        DeviceSelectorModel deviceSelector;
        String deviceName;
        DataCollector collector;
        DataSets data;
        TimeSeriesContext context;
        DataGraph graphFrame;
        int processorIndex;
        String processorString;
        Device currentDevice;
        ProcessorUCDSNMP processorUCDSNMP;
        ProcessorCiscoSNMP processorCiscoSNMP;
        int pollInterval;
        
        //pollInterval = Integer.parseInt(pollField.getText()) * 1000;
        pollInterval = Integer.parseInt(pollField.getText());
        deviceSelector = deviceSelectorPanel.getModel();
        deviceName = deviceSelector.getName();
        if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_HR ) {
            
            try {
                processorIndex = processorHRSNMP.getProcessorsIndex()[((JList)(processorsPane.getViewport().getView())).getSelectedIndex()];
                processorString = (String)((JList)processorsPane.getViewport().getView()).getSelectedValue();
                collector = new ProcessorHRCollector(processorHRSNMP, pollInterval, processorIndex);
                data = new DataSets(DataType.PROCESSOR, collector, device, pollInterval, processorString, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (NullPointerException e) {
                ErrorHandler.modalError(this, "Please enumerate resources on a device and select a processor",
                        "No processor selected");
            } catch (ArrayIndexOutOfBoundsException e) {
                ErrorHandler.modalError(this, "Please select a processor", "No processor selected");
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + device.getName() + "\" is valid",
                        "Unknown host " + device.getName());
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + device.getName(), e);
            } catch (ClassCastException e) {
                ErrorHandler.modalError(null, "Please ensure that device supports processor usage in the Host Resources MIB",
                        "Cannot find processor usage information on device " + device.getName(), e);
            }
            
        } else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_UCD ) {
            try {
                //currentDevice = new Device(deviceField.getText(), communityField.getText(), null, false);
                currentDevice = deviceSelector.loadDevice();
                processorUCDSNMP = new ProcessorUCDSNMP(currentDevice);
                collector = new ProcessorUCDCollector(processorUCDSNMP, (long)pollInterval);
                data = new DataSets(DataType.NETSNMP_PROCESSOR, collector, currentDevice, pollInterval, null, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + deviceName + "\" is valid",
                        "Unknown host " + deviceName);
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + deviceName, e);
            }
        } else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_CISCO ) {
            try {
                //currentDevice = new Device(deviceField.getText(), communityField.getText(), null, false);
                currentDevice = deviceSelector.loadDevice();
                processorCiscoSNMP = new ProcessorCiscoSNMP(currentDevice);
                collector = new ProcessorCiscoCollector(processorCiscoSNMP, pollInterval);
                data = new DataSets(DataType.PROCESSOR, collector, currentDevice, pollInterval, null, DataSets.DIRECTION_NONE, null, storeDataCheckBox.isSelected());
                context = new TimeSeriesContext(data);
                graphFrame = new DataGraph(context);
            } catch (DBException e) {
                ErrorHandler.modalError(null, "Please ensure that database is running and accessible",
                        "Error opening database connection", e);
            } catch (UnknownHostException e) {
                ErrorHandler.modalError(null, "Please ensure that device name \"" + deviceName + "\" is valid",
                        "Unknown host " + deviceName);
            } catch (SNMPException e) {
                ErrorHandler.modalError(null, "Please ensure that device name and community string are correct",
                        "Cannot access SNMP service on device " + deviceName, e);
            }
        }
        
    }//GEN-LAST:event_processorButtonActionPerformed
    
    /** Enumerates interfaces on the given device via SNMP. */
    private void resourcesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resourcesButtonActionPerformed
        DeviceSelectorModel deviceSelector;
        String deviceName;
        JList processorsList;
        JList storageList;
        //ProcessorHRSNMP processorSNMP;

        deviceSelector = deviceSelectorPanel.getModel();
        deviceName = deviceSelector.getName();
        try {
            if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_HR ) {
                //device = new Device(deviceField.getText(), communityField.getText(), null, false);
                device = deviceSelector.loadDevice();
                processorHRSNMP = new ProcessorHRSNMP(device);
                processorHRSNMP.enumerateHostProcessors();
                processorsTitleLabel.setText("Processor list for " + deviceName);
                processorsList = new javax.swing.JList(processorHRSNMP.getProcessorsDescr());
                processorsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                processorsPane.setViewportView((java.awt.Component)processorsList);
                
                memoryHRSNMP = new MemoryHRSNMP(device);
                memoryHRSNMP.enumerateHostStorage();
                storageTitleLabel.setText("Storage list for " + deviceName);
                storageList = new javax.swing.JList(memoryHRSNMP.getStorageDescr());
                storageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                storagePane.setViewportView((java.awt.Component)storageList);
            } else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_UCD ) {
                //device = new Device(deviceField.getText(), communityField.getText(), null, false);
                device = deviceSelector.loadDevice();
                processorsTitleLabel.setText("Processor list for " + deviceName);
                processorsList = new javax.swing.JList(NO_CHOICE);
                processorsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                processorsPane.setViewportView((java.awt.Component)processorsList);
                storageTitleLabel.setText("Memory list for " + deviceName);
                storageList = new javax.swing.JList(MemoryUCDCollector.UCD_MEMORY_TYPES);
                storageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                storagePane.setViewportView((java.awt.Component)storageList);
            } else if ( collectorTypeComboBox.getSelectedIndex() == COLLECTOR_TYPE_CISCO ) {
                //device = new Device(deviceField.getText(), communityField.getText(), null, false);
                device = deviceSelector.loadDevice();
                memoryCiscoSNMP = new MemoryCiscoSNMP(device);
                memoryCiscoSNMP.enumerateCiscoMemoryPools();
                storageTitleLabel.setText("Memory pools for " + deviceName);
                storageList = new javax.swing.JList(memoryCiscoSNMP.getStorageDescr());
                storageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                storagePane.setViewportView((java.awt.Component)storageList);
                processorsTitleLabel.setText("Processor list for " + deviceName);
                processorsList = new javax.swing.JList(NO_CHOICE);
                processorsList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                processorsPane.setViewportView((java.awt.Component)processorsList);
            }
        } catch (DBException e) {
            ErrorHandler.modalError(this, "Ensure that database is reachable",
                    "Cannot retrieve " + deviceName + " from database");
        } catch (UnknownHostException e) {
            ErrorHandler.modalError(this, "Ensure that device \"" + deviceName + "\" exists",
                    "Cannot connect to device " + deviceName);
        } catch (SNMPException e) {
            ErrorHandler.modalError(this, "Ensure that device name and community string are correct",
                    "Cannot connect to device " + deviceName);
        }
        
    }//GEN-LAST:event_resourcesButtonActionPerformed
    
    /*
    public void retrieveCommunity() {
        String community;
        Device candidate;
        
        try {
            candidate = new Device(deviceField.getText());
            community = candidate.retrieveReadCommunity();
            if ( community != null ) {
                communityField.setText(community);
            }
        } catch (DBException e) {
        }
    }
    */
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox collectorTypeComboBox;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JTextField pollField;
    private javax.swing.JLabel pollLabel;
    private javax.swing.JLabel pollUnitsLabel;
    private javax.swing.JButton processorButton;
    private javax.swing.JScrollPane processorsPane;
    private javax.swing.JLabel processorsTitleLabel;
    private javax.swing.JButton resourcesButton;
    private javax.swing.JButton storageButton;
    private javax.swing.JScrollPane storagePane;
    private javax.swing.JLabel storageTitleLabel;
    private javax.swing.JCheckBox storeDataCheckBox;
    // End of variables declaration//GEN-END:variables
    
}
